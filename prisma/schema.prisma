// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id
  email         String?   @unique
  plan          String    @default("free")
  planSince     DateTime? @map("plan_since")
  createdAt     DateTime  @default(now()) @map("created_at")

  // Verifiering & login
  emailVerified DateTime? @map("email_verified")
  passwordHash  String?   @map("password_hash")
  lastLoginAt   DateTime? @map("last_login_at")

  // NEW ↓↓↓
  username      String?   @unique

  profile       Profile?
  ratings       Rating[]
  watchlist     watchlist[]
  purchases     Purchase[]

  groupMembers  GroupMember[] @relation("UserGroupMembers")
  groupsCreated Group[]        @relation("UserGroupsCreated")

  // NEW: vänrelationer
  friendshipsRequested Friendship[] @relation("FriendshipsRequested")
  friendshipsReceived  Friendship[] @relation("FriendshipsReceived")

  verifications Verification[]

  @@map("users")
}

model Profile {
  userId           String    @id @map("user_id")
  dob              DateTime  @db.Date
  uiLanguage       String    @default("sv")   @map("ui_language")
  yearPreference   String    @default("all")  @map("year_preference")
  recycleAfterDays Int       @default(14)     @map("recycle_after_days")
  region           String    @default("SE")
  locale           String    @default("sv-SE")
  providers        Json      @default("[]")   // OBS: Om Prisma klagar på default för Json, ta bort @default här (DB-default finns).
  updatedAt        DateTime  @default(now())  @map("updated_at")

  // Smakprofil
  displayName     String?   @map("display_name")
  favoriteMovie   Json?     @map("favorite_movie")   // JSONB
  favoriteShow    Json?     @map("favorite_show")    // JSONB
  favoriteGenres  String[]  @default([]) @map("favorite_genres")  // text[]
  dislikedGenres  String[]  @default([]) @map("disliked_genres")  // text[]

  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Verification {
  token      String   @id
  userId     String   @map("user_id")
  email      String
  name       String?
  createdAt  DateTime @default(now()) @map("created_at")
  expiresAt  DateTime @map("expires_at")

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([email],  map: "idx_verifications_email")
  @@index([userId], map: "idx_verifications_user_id")
  @@map("verifications")
}

model Rating {
  id        String   @id
  userId    String   @map("user_id")
  tmdbId    Int      @map("tmdb_id")
  mediaType String   @map("media_type")
  decision  String
  decidedAt DateTime @default(now()) @map("decided_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, tmdbId, mediaType], map: "idx_ratings_user_tmdb")
  @@map("ratings")
}

model watchlist {
  id        String   @id
  userId    String   @map("user_id")
  tmdbId    Int      @map("tmdb_id")
  mediaType String   @map("media_type")
  addedAt   DateTime @default(now()) @map("added_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tmdbId, mediaType])
  @@map("watchlist")
}

model Purchase {
  id                    String   @id
  userId                String   @map("user_id")
  stripePaymentIntentId String?  @map("stripe_payment_intent_id")
  amountTotal           Int      @default(0) @map("amount_total")
  currency              String   @default("SEK")
  product               String   @default("lifetime")
  createdAt             DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt], map: "idx_purchases_user")
  @@map("purchases")
}

model Group {
  code      String   @id
  createdBy String   @map("created_by")
  createdAt DateTime @default(now()) @map("created_at")

  members GroupMember[]
  creator User @relation("UserGroupsCreated", fields: [createdBy], references: [id], onDelete: Cascade)

  // NEW: röster i grupp (enkel läsning via relation)
  votes   GroupVote[]

  @@map("groups")
}

model GroupMember {
  groupCode String   @map("group_code")
  userId    String   @map("user_id")
  joinedAt  DateTime @default(now()) @map("joined_at")

  group Group @relation(fields: [groupCode], references: [code], onDelete: Cascade)
  user  User  @relation("UserGroupMembers", fields: [userId], references: [id], onDelete: Cascade)

  @@id([groupCode, userId])
  @@map("group_members")
}

// NEW: Vänförfrågningar + vänner
model Friendship {
  id           String   @id
  requesterId  String   @map("requester_id")
  addresseeId  String   @map("addressee_id")
  status       String   @default("PENDING") // 'PENDING' | 'ACCEPTED' | 'BLOCKED'
  createdAt    DateTime @default(now()) @map("created_at")

  requester User @relation("FriendshipsRequested", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee User @relation("FriendshipsReceived",  fields: [addresseeId], references: [id], onDelete: Cascade)

  @@unique([requesterId, addresseeId])
  @@index([requesterId], map: "idx_friendships_requester")
  @@index([addresseeId], map: "idx_friendships_addressee")
  @@map("friendships")
}

// NEW: Röster för group-swipe
model GroupVote {
  id        String   @id
  groupCode String   @map("group_code")
  userId    String   @map("user_id")
  tmdbId    Int      @map("tmdb_id")
  mediaType String   @map("media_type") // 'movie' | 'tv'
  vote      String   @default("LIKE")    // 'LIKE' | 'DISLIKE' | 'SKIP'
  createdAt DateTime @default(now()) @map("created_at")

  group Group @relation(fields: [groupCode], references: [code], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  // 1 röst per användare/titel/grupp
  @@unique([groupCode, userId, tmdbId, mediaType], map: "uniq_group_vote")
  @@index([groupCode], map: "idx_group_vote_group")
  @@index([userId], map: "idx_group_vote_user")
  @@map("group_votes")
}
